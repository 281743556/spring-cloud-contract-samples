==== Playing with the HTTP contracts

- TDD is about red, green and refactor. We went through the first two. Time to refactor the code.
 We come to the conclusion that the `name` field is unnecessary. In the `BeerController.java` file let's
 create a new class called `BeerRequest` that will contain only age field and let's try to send that
 to our stubbed producer. (<<_beer_request,Show solution>>)
- Let's run the tests again - what will happen is that the tests will fail. That's because in the contract
you have explicitly described that you want the `name` to be there. As you can see all the typos will be
caught during the build time of your project.
  * The same will happen if you leave the `name` but change the `age` to some other value (e.g. 28).
  Our stubs at the moment are very strict. We'll try to fix that in a second
- To fix this you need to go back with your IDE to the producer and modify your HTTP contracts.
  * Just remove the `name` field from the request body.
  * Spring Cloud Contract allows you to provide dynamic values for parts of body, urls, headers etc.
  This is especially useful when working with dates, database ids, UUIDs etc.
  * Let's open the `shouldGrantABeerIfOldEnough.groovy` and go to the request body `age` element
  * Instead of `22` write `$(regex('[2-9][0-9]'))`. Now let's analyze what this is.
    ** In order to tell Spring Cloud Contract that there will be a dynamic value set you have to use either
    the `$()` or `value()` method. They are equivalent.
    ** Next we use `regex()` method that converts your `String` into `Pattern`. In this case we assume
    a 2 digit number greater or equal to `20`
  * Repeat the same process for the `shouldRejectABeerIfTooYoung.groovy` contract but change the
  regular expression to `[0-1][0-9]`
  * Run the building with test skipping and check the output of stubs. You'll see that the generated
  mappings have changed from equality check in JSON Path to regular expression check
  * Go back to the consumer code and run the `BeerControlerTest` again. This time it should pass. You can
  also change the values of age to e.g. `45` for the positive case and `11` for the negative on.

==== Writing the missing consumer messaging implementation

- We've gone through the HTTP scenario and now it's time for the messaging part.
- Let' start with a test as usual. Let's check out the `BeerVerificationListenerTest` test class
  * there are 2 test methods with empty bodies
  * in both cases we need to trigger a message that will get sent to a destination at which our
  listener class is awaiting messages
  * we're missing the triggering part - but we'll add it in a second
- On the consumer side let's check out the `BeerVerificationListener` class.
  * We're using the Spring Cloud Stream's abstraction of a queue / topic which is called a `channel`.
  * There are 2 channels that come out od the box with SC-Stream. These are `input` and `output`.
  Those channels can be found in 2 interfaces - `Sink` and `Source`. `Sink` contains the `input` channel
  which is used for listening for messages and `Source` contains the `output` channel which
  is used to send messages. In the listener class you can see that we use the `Sink` one cause we're waiting for
  a message to be received.
  * We have to configure the `destination`, so the actual name of a queue / topic on which we will be
  listening. To do that you have to set in the `src/main/resources/application.yml` the property
  `spring.cloud.stream.bindings.input.destination: verifications`. That means that the we'll use the
  `input` channel (so the channel in the `Sink` interface) to listen to messages coming from a
  destination called `verifications`.
  * Now that we have configured Spring Cloud Stream let's write the missing feature. If the `eligible` flag
  in the incoming message is `true` - increase the `eligibleCounter` value. Otherwise increment the
  other `notEligibleCounter` one. (<<_missing_listener_code,Show solution>>)
- Now that the implementation is written - let's try to run our `BeerVerificationListenerTest` tests.
Unfortunately they will fail cause no message has been received - we'll still missing that part

==== Turning on Stub Runner in messaging consumer tests

- Time to use Spring Cloud Contract!
  * We need to use Spring Cloud Contract Stub Runner so that it downloads the stubs. Just add the
  `@AutoConfigureStubRunner(workOffline = true, ids = "com.example:{producer_artifact}")` to download
  the latest stubs of `com.example:{producer_artifact}`, with classifier `stubs` and if the JAR
  contains any HTTP stubs then register them at a random port.
  * Now we need a solution to trigger the message. To do that we need to autowire a `StubTrigger` interface.
  Just add `@Autowired StubTrigger stubTrigger` field to your test
  * In the contract on the producer side we've described 2 labels. `accepted_verification` and `rejected_verification`.
  You can use the `StubTrigger#trigger` method to trigger a message with a given label. For example
  if you call `stubTrigger.trigger("accepted_verification")` you'll trigger a message that got described
  with the `accepted_verification` label.
  * Now add the missing `StubTrigger#tigger` method in the test bodies. (<<_missing_triggers,Show solution>>)
  * Run the tests and they should pass!
    * You can change the `destination` name in `src/main/resources/application.yml` to `foo` and rerun the
    tests - you'll see that they'll start failing. That's because you're listening to messages
    at destination `foo` whereas the message is sent to `verifications`
    * You can also play around with the `Verification` payload class. If you change the field name from
    `eligible` to `foo` an rerun the tests - the tests will fail. If you change the type from `boolean`
    to `Integer` (and change the production code too) then the tests will fail due to serialization problems
