==== Generating tests from contracts

- Let's generate the tests! Just call:
+
[source,bash,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
$ ./mvnw clean install
----
+
[source,bash,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
$ ./gradlew clean build publishToMavenLocal
----
  * Suddenly some tests should start failing. Those tests are the autogenerated tests created
  by Spring Cloud Contract
  * The tests lay under `/generated-test-sources/contracts/org/springframework/cloud/contract/verifier/tests/beer`
    in `target` for Maven or `build` for Gradle
  * There will be a test for each folder in which you store your contracts. The name of the test class
    will be the name of that folder
  * Each of the contracts will be a single test inside that test class
  * If you check out the generated `RestTest` you'll notice that the dynamic parts of the `request` part
    of the contract got converted to a concrete value. Any dynamic bits on the `response` side would be
    converted into matchers.
- Time to fix the broken tests. We need to do that by providing the missing implementation.

==== Fixing broken HTTP tests

- Let's start with HTTP
  * First let's write the missing implementation in `ProducerController`. The logic to be written
    is extremely simple - if the `personCheckingService.shouldGetBeer(...)` returns `true` then we
    should return `new Response(BeerCheckStatus.OK)`. Otherwise `new Response(BeerCheckStatus.NOT_OK)`.
    (<<_producerController_implementation,Show solution>>)
- Let's fix the `BeerRestBase` class now
  * The idea of CDC is *NOT TO TEST* every single feature. Contract tests are there to see if the API
    is matched, *NOT* that the feature is working. That's why we shouldn't be accessing databases etc.
    That means that we will work with mock of the `PersonCheckingService`. (<<_beerrestbase,Show solution>>)
  * Let's annotate the test class with `@RunWith(MockitoJUnitRunner.class)` to enable Mockito runner.
+
[source,java]
----
@RunWith(MockitoJUnitRunner.class)
public abstract class BeerRestBase {
...
}
----
  * We'll want to test the `ProducerController` so we can create a field `@InjectMocks ProducerController
    producerController`. Mockito will inject any mocks for us via the constructor.
+
[source,java]
----
    @Mock PersonCheckingService personCheckingService;
    @InjectMocks ProducerController producerController;

    @Before
    public void setup() {
        given(personCheckingService.shouldGetBeer(argThat(oldEnough()))).willReturn(true);
    }
----
  * It won't compile cause we don't have the `oldEnough()` method but don't worry. So this line stubs
 the `shouldGetBeer` method in such a way that if the user is old enough then the method will return
 true. Let's now add the `oldEnoughMethod()`
+
[source,java]
----
	private TypeSafeMatcher<PersonToCheck> oldEnough() {
		return new TypeSafeMatcher<PersonToCheck>() {
			@Override protected boolean matchesSafely(PersonToCheck personToCheck) {
				return personToCheck.age >= 20;
			}
			@Override public void describeTo(Description description) {
			}
		};
	}
----
  * We're using the `TypeSafeMatcher` from Hamcrest to create a matcher for `PersonToCheck`. In this case
if the person to check is older or is 20 then the method `shouldGetBeer` method will return `true`.
  * Now we need to configure http://rest-assured.io/[RestAssured] that is used by Spring Cloud Contract
to send requests. In our case we want to profit from MockMvc. In order to set the `ProducerController`
with RestAssured it's enough to call `RestAssuredMockMvc.standaloneSetup(producerController);`
+
[source,java]
----
@RunWith(MockitoJUnitRunner.class)
public abstract class BeerRestBase {

    @Mock PersonCheckingService personCheckingService;
    @InjectMocks ProducerController producerController;

    @Before
    public void setup() {
        given(personCheckingService.shouldGetBeer(argThat(oldEnough()))).willReturn(true);
        RestAssuredMockMvc.standaloneSetup(producerController);
    }

    private TypeSafeMatcher<PersonToCheck> oldEnough() {
        return new TypeSafeMatcher<PersonToCheck>() {
            @Override protected boolean matchesSafely(PersonToCheck personToCheck) {
                return personToCheck.age >= 20;
            }
            @Override public void describeTo(Description description) {
            }
        };
    }
}
----
  * With mocks and RestAssured setup - we're ready to run our HTTP based autogenerated tests