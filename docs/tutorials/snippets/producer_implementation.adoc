==== Generating tests from contracts

- Let's generate the tests! Just call:
+
[source,bash,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
$ ./mvnw clean install
----
+
[source,bash,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
$ ./gradlew clean build publishToMavenLocal
----
  * Suddenly some tests should start failing. Those tests are the autogenerated tests created
  by Spring Cloud Contract
  * The tests lay under `/generated-test-sources/contracts/org/springframework/cloud/contract/verifier/tests/beer`
    in `target` for Maven or `build` for Gradle
  * There will be a test for each folder in which you store your contracts. The name of the test class
    will be the name of that folder
  * Each of the contracts will be a single test inside that test class
  * If you check out the generated `RestTest` you'll notice that the dynamic parts of the `request` part
    of the contract got converted to a concrete value. Any dynamic bits on the `response` side would be
    converted into matchers.
- Time to fix the broken tests. We need to do that by providing the missing implementation.

==== Fixing broken HTTP tests

- Let's start with HTTP
  * First let's write the missing implementation in `ProducerController`. The logic to be written
    is extremely simple - if the `personCheckingService.shouldGetBeer(...)` returns `true` then we
    should return `new Response(BeerCheckStatus.OK)`. Otherwise `new Response(BeerCheckStatus.NOT_OK)`.
    (<<_producerController_implementation,Show solution>>)
- Let's fix the `BeerRestBase` class now
  * The idea of CDC is *NOT TO TEST* every single feature. Contract tests are there to see if the API
    is matched, *NOT* that the feature is working. That's why we shouldn't be accessing databases etc.
    That means that we will work with mock of the `PersonCheckingService`. (<<_beerrestbase,Show solution>>)
  * Let's annotate the test class with `@RunWith(MockitoJUnitRunner.class)` to enable Mockito runner.
+
[source,java]
----
@RunWith(MockitoJUnitRunner.class)
public abstract class BeerRestBase {
...
}
----
  * We'll want to test the `ProducerController` so we can create a field `@InjectMocks ProducerController
    producerController`. Mockito will inject any mocks for us via the constructor.
+
[source,java]
----
    @Mock PersonCheckingService personCheckingService;
    @InjectMocks ProducerController producerController;

    @Before
    public void setup() {
        given(personCheckingService.shouldGetBeer(argThat(oldEnough()))).willReturn(true);
    }
----
  * It won't compile cause we don't have the `oldEnough()` method but don't worry. So this line stubs
 the `shouldGetBeer` method in such a way that if the user is old enough then the method will return
 true. Let's now add the `oldEnoughMethod()`
+
[source,java]
----
	private TypeSafeMatcher<PersonToCheck> oldEnough() {
		return new TypeSafeMatcher<PersonToCheck>() {
			@Override protected boolean matchesSafely(PersonToCheck personToCheck) {
				return personToCheck.age >= 20;
			}
			@Override public void describeTo(Description description) {
			}
		};
	}
----
  * We're using the `TypeSafeMatcher` from Hamcrest to create a matcher for `PersonToCheck`. In this case
if the person to check is older or is 20 then the method `shouldGetBeer` method will return `true`.
  * Now we need to configure http://rest-assured.io/[RestAssured] that is used by Spring Cloud Contract
to send requests. In our case we want to profit from MockMvc. In order to set the `ProducerController`
with RestAssured it's enough to call `RestAssuredMockMvc.standaloneSetup(producerController);`
+
[source,java]
----
@RunWith(MockitoJUnitRunner.class)
public abstract class BeerRestBase {

    @Mock PersonCheckingService personCheckingService;
    @InjectMocks ProducerController producerController;

    @Before
    public void setup() {
        given(personCheckingService.shouldGetBeer(argThat(oldEnough()))).willReturn(true);
        RestAssuredMockMvc.standaloneSetup(producerController);
    }

    private TypeSafeMatcher<PersonToCheck> oldEnough() {
        return new TypeSafeMatcher<PersonToCheck>() {
            @Override protected boolean matchesSafely(PersonToCheck personToCheck) {
                return personToCheck.age >= 20;
            }
            @Override public void describeTo(Description description) {
            }
        };
    }
}
----
  * With mocks and RestAssured setup - we're ready to run our HTTP based autogenerated tests

==== Fixing broken messaging tests

- Now let's go to the messaging part.
- Let's check out the `src/main/resources/application.yml` file whether it contains the proper
destination set for `spring.cloud.stream.bindings.output.destination`. If not then let's set it
to `verifications` - this is the queue / topic we'd like to receive the message from
- We're trying to do TDD so let's move to `BeerMessagingBase` test class. The first thing we need to do is to
add the `@AutoConfigureMessageVerifier` annotation on the test class. That will configure
the setup related to messaging and Spring Cloud Contract.
+
[source,java]
----
@RunWith(SpringRunner.class)
@SpringBootTest(classes = ProducerApplication.class, webEnvironment = SpringBootTest.WebEnvironment.NONE)
@AutoConfigureMessageVerifier
public abstract class BeerMessagingBase {
...
}
----
- We need to prepare some setup for our tests. To do that we'll need to clear any remaining
messages that could break our tests. To do that we'll use the Spring Cloud Contract `MessageVerifier`
abstraction (it allows to send and receive messages from e.g. Spring Cloud Stream, Sprig Integration, Apache Camel.)
+
[source,java]
----
@RunWith(SpringRunner.class)
@SpringBootTest(classes = ProducerApplication.class, webEnvironment = SpringBootTest.WebEnvironment.NONE)
@AutoConfigureMessageVerifier
public abstract class BeerMessagingBase {
    @Inject MessageVerifier messaging;
	@Autowired PersonCheckingService personCheckingService;

	@Before
	public void setup() {
		// let's clear any remaining messages
		// output == destination or channel name
		this.messaging.receive("output", 100, TimeUnit.MILLISECONDS);
	}

	public void clientIsOldEnough() {
    }

    public void clientIsTooYoung() {
    }
}
----
- In the `clientIsOldEnough()` and `clientIsTooYoung()` we need the logic to trigger a message.
What triggers a message will be the implementation of the `PersonCheckingService#shouldGetBeer`.
- For `clientIsOldEnough()` we can use a `PersonToCheck` of age `25` for example and
`clientIsTooYoung` can have age `5`. (<<_beermessagingbase,Show solution>>)
- We can run the test which will obviously fail because we have a missing implementation. Let's move
to `AgeCheckingPersonCheckingService`

==== Writing the missing producer messaging implementation

- We need to check if the person's age is greater or equal to 20 - if that's the case then the
we need to send the properly generated `Verification` object. In order to send a message you can use the
following code `source.output().send(MessageBuilder.withPayload(new Verification(true)).build())`.
In this case we're sending a message to the `output` channel (that is bound to `verifications` destination).
(<<_messaging_implementation,Show solution>>)
- Let's run the tests again - they should all pass!
- Now let's ensure that we can successfully publish artifacts to Maven local
+
[source,bash,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
$ ./mvnw clean install
----
+
[source,bash,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
$ ./gradlew clean build publishToMavenLocal
----